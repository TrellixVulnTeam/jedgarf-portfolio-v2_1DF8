{
  "ast": null,
  "code": "/* eslint-env browser */\nconst STYLES_HYDRATOR = /\\.([^{:]+)(:[^{]+)?{(?:[^}]*;)?([^}]*?)}/g;\nconst KEYFRAMES_HYRDATOR = /@keyframes ([^{]+){((?:(?:from|to|(?:\\d+\\.?\\d*%))\\{(?:[^}])*})*)}/g;\nconst FONT_FACE_HYDRATOR = /@font-face\\{font-family:([^;]+);([^}]*)\\}/g;\n\nfunction hydrateStyles(cache, hydrator, css) {\n  let match;\n\n  while (match = hydrator.exec(css)) {\n    const [, id, pseudo, key] = match;\n\n    if (true && process.env.NODE_ENV !== \"production\" && window.__STYLETRON_DEVTOOLS__) {\n      hydrateDevtoolsRule(match[0]);\n    }\n\n    const fullKey = pseudo ? `${pseudo}${key}` : key;\n    cache.cache[fullKey] = id; // set cache without triggering side effects\n\n    cache.idGenerator.increment(); // increment id\n  }\n}\n\nfunction hydrate(cache, hydrator, css) {\n  let match;\n\n  while (match = hydrator.exec(css)) {\n    const [, id, key] = match;\n\n    if (true && process.env.NODE_ENV !== \"production\" && window.__STYLETRON_DEVTOOLS__) {\n      hydrateDevtoolsRule(match[0]);\n    }\n\n    cache.cache[key] = id; // set cache without triggering side effects\n\n    cache.idGenerator.increment(); // increment id\n  }\n}\n\nimport SequentialIDGenerator from \"../sequential-id-generator\";\nimport { Cache, MultiCache } from \"../cache\";\nimport injectStylePrefixed from \"../inject-style-prefixed\";\nimport { styleBlockToRule, atomicSelector, keyframesBlockToRule, declarationsToBlock, keyframesToBlock, fontFaceBlockToRule } from \"../css\";\nimport { insertRuleIntoDevtools, hydrateDevtoolsRule } from \"../dev-tool\";\n\nclass StyletronClient {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.styleElements = {};\n    const styleIdGenerator = new SequentialIDGenerator(opts.prefix);\n\n    const onNewStyle = (cache, id, value) => {\n      const {\n        pseudo,\n        block\n      } = value;\n      const sheet = this.styleElements[cache.key].sheet;\n      const selector = atomicSelector(id, pseudo);\n      const rule = styleBlockToRule(selector, block);\n\n      try {\n        sheet.insertRule(rule, sheet.cssRules.length);\n\n        if (true && process.env.NODE_ENV !== \"production\" && window.__STYLETRON_DEVTOOLS__) {\n          insertRuleIntoDevtools(selector, block);\n        }\n      } catch (e) {\n        if (process.env.NODE_ENV !== \"production\") {\n          // eslint-disable-next-line no-console\n          console.warn(`Failed to inject CSS: \"${rule}\". Perhaps this has invalid or un-prefixed properties?`);\n        }\n      }\n    }; // Setup style cache\n\n\n    this.styleCache = new MultiCache(styleIdGenerator, (media, _cache, insertBeforeMedia) => {\n      const styleElement = document.createElement(\"style\");\n      styleElement.media = media;\n\n      if (insertBeforeMedia === void 0) {\n        this.container.appendChild(styleElement);\n      } else {\n        const insertBeforeIndex = findSheetIndexWithMedia(this.container.children, insertBeforeMedia);\n        this.container.insertBefore(styleElement, this.container.children[insertBeforeIndex]);\n      }\n\n      this.styleElements[media] = styleElement;\n    }, onNewStyle);\n    this.keyframesCache = new Cache(new SequentialIDGenerator(opts.prefix), (cache, id, value) => {\n      this.styleCache.getCache(\"\");\n      const sheet = this.styleElements[\"\"].sheet;\n      const rule = keyframesBlockToRule(id, keyframesToBlock(value));\n\n      try {\n        sheet.insertRule(rule, sheet.cssRules.length);\n      } catch (e) {\n        if (process.env.NODE_ENV !== \"production\") {\n          // eslint-disable-next-line no-console\n          console.warn(`Failed to inject CSS: \"${rule}\". Perhaps this has invalid or un-prefixed properties?`);\n        }\n      }\n    });\n    this.fontFaceCache = new Cache(new SequentialIDGenerator(opts.prefix), (cache, id, value) => {\n      this.styleCache.getCache(\"\");\n      const sheet = this.styleElements[\"\"].sheet;\n      const rule = fontFaceBlockToRule(id, declarationsToBlock(value));\n\n      try {\n        sheet.insertRule(rule, sheet.cssRules.length);\n      } catch (e) {\n        if (process.env.NODE_ENV !== \"production\") {\n          // eslint-disable-next-line no-console\n          console.warn(`Failed to inject CSS: \"${rule}\". Perhaps this has invalid or un-prefixed properties?`);\n        }\n      }\n    });\n\n    if (opts.container) {\n      this.container = opts.container;\n    } // Hydrate\n\n\n    if (opts.hydrate && opts.hydrate.length > 0) {\n      // infer container from parent element\n      if (!this.container) {\n        const parentElement = opts.hydrate[0].parentElement;\n\n        if (parentElement !== null && parentElement !== void 0) {\n          this.container = parentElement;\n        }\n      }\n\n      for (let i = 0; i < opts.hydrate.length; i++) {\n        const element = opts.hydrate[i];\n        const hydrateType = element.getAttribute(\"data-hydrate\");\n\n        if (hydrateType === \"font-face\") {\n          hydrate(this.fontFaceCache, FONT_FACE_HYDRATOR, element.textContent);\n          continue;\n        }\n\n        if (hydrateType === \"keyframes\") {\n          hydrate(this.keyframesCache, KEYFRAMES_HYRDATOR, element.textContent);\n          continue;\n        }\n\n        const key = element.media ? element.media : \"\";\n        this.styleElements[key] = element;\n        const cache = new Cache(styleIdGenerator, onNewStyle);\n        cache.key = key;\n        hydrateStyles(cache, STYLES_HYDRATOR, element.textContent);\n        this.styleCache.sortedCacheKeys.push(key);\n        this.styleCache.caches[key] = cache;\n      }\n    }\n\n    if (!this.container) {\n      if (document.head === null) {\n        throw new Error(\"No container provided and `document.head` was null\");\n      }\n\n      this.container = document.head;\n    }\n  }\n\n  renderStyle(style) {\n    return injectStylePrefixed(this.styleCache, style, \"\", \"\");\n  }\n\n  renderFontFace(fontFace) {\n    const key = declarationsToBlock(fontFace);\n    return this.fontFaceCache.addValue(key, fontFace);\n  }\n\n  renderKeyframes(keyframes) {\n    const key = keyframesToBlock(keyframes);\n    return this.keyframesCache.addValue(key, keyframes);\n  }\n\n}\n\nexport default StyletronClient;\n\nfunction findSheetIndexWithMedia(children, media) {\n  let index = 0;\n\n  for (; index < children.length; index++) {\n    const child = children[index];\n\n    if (child.tagName === \"STYLE\" && child.media === media) {\n      return index;\n    }\n  }\n\n  return -1;\n}",
  "map": {
    "version": 3,
    "sources": [
      "src/client/client.ts"
    ],
    "names": [
      "STYLES_HYDRATOR",
      "KEYFRAMES_HYRDATOR",
      "FONT_FACE_HYDRATOR",
      "match",
      "hydrator",
      "window",
      "hydrateDevtoolsRule",
      "fullKey",
      "pseudo",
      "key",
      "cache",
      "constructor",
      "opts",
      "styleIdGenerator",
      "onNewStyle",
      "block",
      "sheet",
      "selector",
      "atomicSelector",
      "rule",
      "styleBlockToRule",
      "insertRuleIntoDevtools",
      "console",
      "styleElement",
      "document",
      "insertBeforeMedia",
      "insertBeforeIndex",
      "findSheetIndexWithMedia",
      "keyframesBlockToRule",
      "keyframesToBlock",
      "fontFaceBlockToRule",
      "declarationsToBlock",
      "parentElement",
      "i",
      "element",
      "hydrateType",
      "hydrate",
      "hydrateStyles",
      "renderStyle",
      "injectStylePrefixed",
      "renderFontFace",
      "renderKeyframes",
      "index",
      "children",
      "child"
    ],
    "mappings": "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",
    "sourcesContent": [
      "/* eslint-env browser */\n\ndeclare var __DEV__: boolean;\n\ndeclare var __BROWSER__: boolean;\n\nconst STYLES_HYDRATOR = /\\.([^{:]+)(:[^{]+)?{(?:[^}]*;)?([^}]*?)}/g;\nconst KEYFRAMES_HYRDATOR =\n  /@keyframes ([^{]+){((?:(?:from|to|(?:\\d+\\.?\\d*%))\\{(?:[^}])*})*)}/g;\nconst FONT_FACE_HYDRATOR = /@font-face\\{font-family:([^;]+);([^}]*)\\}/g;\n\ntype hydratorT =\n  | typeof STYLES_HYDRATOR\n  | typeof KEYFRAMES_HYRDATOR\n  | typeof FONT_FACE_HYDRATOR;\n\nfunction hydrateStyles<T>(cache: Cache<T>, hydrator: hydratorT, css: string) {\n  let match;\n  while ((match = hydrator.exec(css))) {\n    const [, id, pseudo, key] = match;\n    if (__BROWSER__ && __DEV__ && window.__STYLETRON_DEVTOOLS__) {\n      hydrateDevtoolsRule(match[0]);\n    }\n    const fullKey = pseudo ? `${pseudo}${key}` : key;\n    cache.cache[fullKey] = id; // set cache without triggering side effects\n    cache.idGenerator.increment(); // increment id\n  }\n}\n\nfunction hydrate<T>(cache: Cache<T>, hydrator: hydratorT, css: string) {\n  let match;\n  while ((match = hydrator.exec(css))) {\n    const [, id, key] = match;\n    if (__BROWSER__ && __DEV__ && window.__STYLETRON_DEVTOOLS__) {\n      hydrateDevtoolsRule(match[0]);\n    }\n    cache.cache[key] = id; // set cache without triggering side effects\n    cache.idGenerator.increment(); // increment id\n  }\n}\n\nimport SequentialIDGenerator from \"../sequential-id-generator\";\n\nimport type {\n  StandardEngine,\n  KeyframesObject,\n  FontFaceObject,\n  StyleObject,\n} from \"styletron-standard\";\n\nimport {Cache, MultiCache} from \"../cache\";\n\nimport injectStylePrefixed from \"../inject-style-prefixed\";\n\nimport {\n  styleBlockToRule,\n  atomicSelector,\n  keyframesBlockToRule,\n  declarationsToBlock,\n  keyframesToBlock,\n  fontFaceBlockToRule,\n} from \"../css\";\nimport {insertRuleIntoDevtools, hydrateDevtoolsRule} from \"../dev-tool\";\n\ntype hydrateT =\n  | HTMLCollectionOf<HTMLStyleElement>\n  | Array<HTMLStyleElement>\n  | NodeListOf<HTMLStyleElement>;\n\ntype optionsT = {\n  hydrate?: hydrateT;\n  container?: Element;\n  prefix?: string;\n};\n\nclass StyletronClient implements StandardEngine {\n  container: Element;\n  styleElements: {\n    [x: string]: HTMLStyleElement;\n  };\n  fontFaceSheet: HTMLStyleElement;\n  keyframesSheet: HTMLStyleElement;\n\n  styleCache: MultiCache<{\n    pseudo: string;\n    block: string;\n  }>;\n  keyframesCache: Cache<KeyframesObject>;\n  fontFaceCache: Cache<FontFaceObject>;\n\n  constructor(opts: optionsT = {}) {\n    this.styleElements = {};\n\n    const styleIdGenerator = new SequentialIDGenerator(opts.prefix);\n    const onNewStyle = (cache, id, value) => {\n      const {pseudo, block} = value;\n      const sheet: CSSStyleSheet = this.styleElements[cache.key].sheet as any;\n      const selector = atomicSelector(id, pseudo);\n      const rule = styleBlockToRule(selector, block);\n      try {\n        sheet.insertRule(rule, sheet.cssRules.length);\n        if (__BROWSER__ && __DEV__ && window.__STYLETRON_DEVTOOLS__) {\n          insertRuleIntoDevtools(selector, block);\n        }\n      } catch (e) {\n        if (__DEV__) {\n          // eslint-disable-next-line no-console\n          console.warn(\n            `Failed to inject CSS: \"${rule}\". Perhaps this has invalid or un-prefixed properties?`,\n          );\n        }\n      }\n    };\n\n    // Setup style cache\n    this.styleCache = new MultiCache(\n      styleIdGenerator,\n      (media, _cache, insertBeforeMedia) => {\n        const styleElement = document.createElement(\"style\");\n        styleElement.media = media;\n        if (insertBeforeMedia === void 0) {\n          this.container.appendChild(styleElement);\n        } else {\n          const insertBeforeIndex = findSheetIndexWithMedia(\n            this.container.children,\n            insertBeforeMedia,\n          );\n          this.container.insertBefore(\n            styleElement,\n            this.container.children[insertBeforeIndex],\n          );\n        }\n\n        this.styleElements[media] = styleElement;\n      },\n      onNewStyle,\n    );\n\n    this.keyframesCache = new Cache(\n      new SequentialIDGenerator(opts.prefix),\n      (cache, id, value) => {\n        this.styleCache.getCache(\"\");\n        const sheet: CSSStyleSheet = this.styleElements[\"\"].sheet as any;\n        const rule = keyframesBlockToRule(id, keyframesToBlock(value));\n        try {\n          sheet.insertRule(rule, sheet.cssRules.length);\n        } catch (e) {\n          if (__DEV__) {\n            // eslint-disable-next-line no-console\n            console.warn(\n              `Failed to inject CSS: \"${rule}\". Perhaps this has invalid or un-prefixed properties?`,\n            );\n          }\n        }\n      },\n    );\n\n    this.fontFaceCache = new Cache(\n      new SequentialIDGenerator(opts.prefix),\n      (cache, id, value) => {\n        this.styleCache.getCache(\"\");\n        const sheet: CSSStyleSheet = this.styleElements[\"\"].sheet as any;\n        const rule = fontFaceBlockToRule(id, declarationsToBlock(value));\n        try {\n          sheet.insertRule(rule, sheet.cssRules.length);\n        } catch (e) {\n          if (__DEV__) {\n            // eslint-disable-next-line no-console\n            console.warn(\n              `Failed to inject CSS: \"${rule}\". Perhaps this has invalid or un-prefixed properties?`,\n            );\n          }\n        }\n      },\n    );\n\n    if (opts.container) {\n      this.container = opts.container;\n    }\n\n    // Hydrate\n    if (opts.hydrate && opts.hydrate.length > 0) {\n      // infer container from parent element\n      if (!this.container) {\n        const parentElement = opts.hydrate[0].parentElement;\n        if (parentElement !== null && parentElement !== void 0) {\n          this.container = parentElement;\n        }\n      }\n\n      for (let i = 0; i < opts.hydrate.length; i++) {\n        const element = opts.hydrate[i];\n        const hydrateType = element.getAttribute(\"data-hydrate\");\n        if (hydrateType === \"font-face\") {\n          hydrate(this.fontFaceCache, FONT_FACE_HYDRATOR, element.textContent);\n          continue;\n        }\n        if (hydrateType === \"keyframes\") {\n          hydrate(this.keyframesCache, KEYFRAMES_HYRDATOR, element.textContent);\n          continue;\n        }\n        const key = element.media ? element.media : \"\";\n        this.styleElements[key] = element;\n        const cache = new Cache(styleIdGenerator, onNewStyle);\n        cache.key = key;\n        hydrateStyles(cache, STYLES_HYDRATOR, element.textContent);\n        this.styleCache.sortedCacheKeys.push(key);\n        this.styleCache.caches[key] = cache;\n      }\n    }\n\n    if (!this.container) {\n      if (document.head === null) {\n        throw new Error(\"No container provided and `document.head` was null\");\n      }\n      this.container = document.head;\n    }\n  }\n\n  renderStyle(style: StyleObject): string {\n    return injectStylePrefixed(this.styleCache, style, \"\", \"\");\n  }\n\n  renderFontFace(fontFace: FontFaceObject): string {\n    const key = declarationsToBlock(fontFace);\n    return this.fontFaceCache.addValue(key, fontFace);\n  }\n\n  renderKeyframes(keyframes: KeyframesObject): string {\n    const key = keyframesToBlock(keyframes);\n    return this.keyframesCache.addValue(key, keyframes);\n  }\n}\n\nexport default StyletronClient;\n\nfunction findSheetIndexWithMedia(children, media) {\n  let index = 0;\n  for (; index < children.length; index++) {\n    const child = children[index];\n    if (\n      child.tagName === \"STYLE\" &&\n      (child as any as HTMLStyleElement).media === media\n    ) {\n      return index;\n    }\n  }\n\n  return -1;\n}\n"
    ]
  },
  "metadata": {},
  "sourceType": "module"
}
