{
  "ast": null,
  "code": "import SequentialIDGenerator from \"../sequential-id-generator\";\nimport { Cache, MultiCache } from \"../cache\";\nimport injectStylePrefixed from \"../inject-style-prefixed\";\nimport { styleBlockToRule, atomicSelector, keyframesBlockToRule, declarationsToBlock, keyframesToBlock, fontFaceBlockToRule } from \"../css\";\n\nclass StyletronServer {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.styleRules = {\n      \"\": \"\"\n    };\n    this.styleCache = new MultiCache(new SequentialIDGenerator(opts.prefix), media => {\n      this.styleRules[media] = \"\";\n    }, (cache, id, value) => {\n      const {\n        pseudo,\n        block\n      } = value;\n      this.styleRules[cache.key] += styleBlockToRule(atomicSelector(id, pseudo), block);\n    });\n    this.fontFaceRules = \"\";\n    this.fontFaceCache = new Cache(new SequentialIDGenerator(opts.prefix), (cache, id, value) => {\n      this.fontFaceRules += fontFaceBlockToRule(id, declarationsToBlock(value));\n    });\n    this.keyframesRules = \"\";\n    this.keyframesCache = new Cache(new SequentialIDGenerator(opts.prefix), (cache, id, value) => {\n      this.keyframesRules += keyframesBlockToRule(id, keyframesToBlock(value));\n    });\n  }\n\n  renderStyle(style) {\n    return injectStylePrefixed(this.styleCache, style, \"\", \"\");\n  }\n\n  renderFontFace(fontFace) {\n    const key = JSON.stringify(fontFace);\n    return this.fontFaceCache.addValue(key, fontFace);\n  }\n\n  renderKeyframes(keyframes) {\n    const key = JSON.stringify(keyframes);\n    return this.keyframesCache.addValue(key, keyframes);\n  }\n\n  getStylesheets() {\n    return [...(this.keyframesRules.length ? [{\n      css: this.keyframesRules,\n      attrs: {\n        \"data-hydrate\": \"keyframes\"\n      }\n    }] : []), ...(this.fontFaceRules.length ? [{\n      css: this.fontFaceRules,\n      attrs: {\n        \"data-hydrate\": \"font-face\"\n      }\n    }] : []), ...sheetify(this.styleRules, this.styleCache.getSortedCacheKeys())];\n  }\n\n  getStylesheetsHtml() {\n    let className = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"_styletron_hydrate_\";\n    return generateHtmlString(this.getStylesheets(), className);\n  }\n\n  getCss() {\n    return this.keyframesRules + this.fontFaceRules + stringify(this.styleRules, this.styleCache.getSortedCacheKeys());\n  }\n\n}\n\nexport function generateHtmlString(sheets, className) {\n  let html = \"\";\n\n  for (let i = 0; i < sheets.length; i++) {\n    const sheet = sheets[i];\n    const {\n      class: originalClassName,\n      ...rest\n    } = sheet.attrs;\n    const attrs = {\n      class: originalClassName ? `${className} ${originalClassName}` : className,\n      ...rest\n    };\n    html += `<style${attrsToString(attrs)}>${sheet.css}</style>`;\n  }\n\n  return html;\n}\n\nfunction attrsToString(attrs) {\n  let result = \"\";\n\n  for (const attr in attrs) {\n    const value = attrs[attr];\n\n    if (value === true) {\n      result += \" \" + attr;\n    } else if (value !== false) {\n      result += ` ${attr}=\"${value}\"`;\n    }\n  }\n\n  return result;\n}\n\nfunction stringify(styleRules, sortedCacheKeys) {\n  let result = \"\";\n  sortedCacheKeys.forEach(cacheKey => {\n    const rules = styleRules[cacheKey];\n\n    if (cacheKey !== \"\") {\n      result += `@media ${cacheKey}{${rules}}`;\n    } else {\n      result += rules;\n    }\n  });\n  return result;\n}\n\nfunction sheetify(styleRules, sortedCacheKeys) {\n  if (sortedCacheKeys.length === 0) {\n    return [{\n      css: \"\",\n      attrs: {}\n    }];\n  }\n\n  const sheets = [];\n  sortedCacheKeys.forEach(cacheKey => {\n    // omit media (cacheKey) attribute if empty\n    const attrs = cacheKey === \"\" ? {} : {\n      media: cacheKey\n    };\n    sheets.push({\n      css: styleRules[cacheKey],\n      attrs\n    });\n  });\n  return sheets;\n}\n\nexport default StyletronServer;",
  "map": {
    "version": 3,
    "sources": [
      "src/server/server.ts"
    ],
    "names": [
      "constructor",
      "opts",
      "media",
      "block",
      "cache",
      "styleBlockToRule",
      "atomicSelector",
      "fontFaceBlockToRule",
      "declarationsToBlock",
      "keyframesBlockToRule",
      "keyframesToBlock",
      "renderStyle",
      "injectStylePrefixed",
      "renderFontFace",
      "key",
      "JSON",
      "renderKeyframes",
      "getStylesheets",
      "css",
      "attrs",
      "sheetify",
      "getStylesheetsHtml",
      "className",
      "generateHtmlString",
      "getCss",
      "stringify",
      "html",
      "i",
      "sheets",
      "sheet",
      "class",
      "rest",
      "originalClassName",
      "attrsToString",
      "result",
      "value",
      "attr",
      "sortedCacheKeys",
      "cacheKey",
      "rules",
      "styleRules"
    ],
    "mappings": "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",
    "sourcesContent": [
      "import SequentialIDGenerator from \"../sequential-id-generator\";\n\nimport type {StandardEngine} from \"styletron-standard\";\n\nimport {Cache, MultiCache} from \"../cache\";\n\nimport injectStylePrefixed from \"../inject-style-prefixed\";\n\nimport type {\n  StyleObject,\n  FontFaceObject,\n  KeyframesObject,\n} from \"styletron-standard\";\n\nimport {\n  styleBlockToRule,\n  atomicSelector,\n  keyframesBlockToRule,\n  declarationsToBlock,\n  keyframesToBlock,\n  fontFaceBlockToRule,\n} from \"../css\";\n\nexport type attrsT = {\n  \"data-hydrate\"?: \"keyframes\" | \"font-face\";\n  media?: string;\n  class?: string;\n};\n\nexport type sheetT = {\n  css: string;\n  attrs: attrsT;\n};\n\ntype optionsT = {\n  prefix?: string;\n};\n\nclass StyletronServer implements StandardEngine {\n  styleCache: MultiCache<{\n    pseudo: string;\n    block: string;\n  }>;\n  keyframesCache: Cache<KeyframesObject>;\n  fontFaceCache: Cache<FontFaceObject>;\n  styleRules: {\n    [x: string]: string;\n  };\n  keyframesRules: string;\n  fontFaceRules: string;\n\n  constructor(opts: optionsT = {}) {\n    this.styleRules = {\"\": \"\"};\n    this.styleCache = new MultiCache(\n      new SequentialIDGenerator(opts.prefix),\n      media => {\n        this.styleRules[media] = \"\";\n      },\n      (cache, id, value) => {\n        const {pseudo, block} = value;\n        this.styleRules[cache.key] += styleBlockToRule(\n          atomicSelector(id, pseudo),\n          block,\n        );\n      },\n    );\n\n    this.fontFaceRules = \"\";\n    this.fontFaceCache = new Cache(\n      new SequentialIDGenerator(opts.prefix),\n      (cache, id, value) => {\n        this.fontFaceRules += fontFaceBlockToRule(\n          id,\n          declarationsToBlock(value),\n        );\n      },\n    );\n\n    this.keyframesRules = \"\";\n    this.keyframesCache = new Cache(\n      new SequentialIDGenerator(opts.prefix),\n      (cache, id, value) => {\n        this.keyframesRules += keyframesBlockToRule(\n          id,\n          keyframesToBlock(value),\n        );\n      },\n    );\n  }\n\n  renderStyle(style: StyleObject): string {\n    return injectStylePrefixed(this.styleCache, style, \"\", \"\");\n  }\n\n  renderFontFace(fontFace: FontFaceObject): string {\n    const key = JSON.stringify(fontFace);\n    return this.fontFaceCache.addValue(key, fontFace);\n  }\n\n  renderKeyframes(keyframes: KeyframesObject): string {\n    const key = JSON.stringify(keyframes);\n    return this.keyframesCache.addValue(key, keyframes);\n  }\n\n  getStylesheets(): Array<sheetT> {\n    return [\n      ...(this.keyframesRules.length\n        ? [\n            {\n              css: this.keyframesRules,\n              attrs: {\"data-hydrate\": \"keyframes\"},\n            } as sheetT,\n          ]\n        : []),\n      ...(this.fontFaceRules.length\n        ? [\n            {\n              css: this.fontFaceRules,\n              attrs: {\"data-hydrate\": \"font-face\"},\n            } as sheetT,\n          ]\n        : []),\n      ...sheetify(this.styleRules, this.styleCache.getSortedCacheKeys()),\n    ];\n  }\n\n  getStylesheetsHtml(className: string = \"_styletron_hydrate_\") {\n    return generateHtmlString(this.getStylesheets(), className);\n  }\n\n  getCss() {\n    return (\n      this.keyframesRules +\n      this.fontFaceRules +\n      stringify(this.styleRules, this.styleCache.getSortedCacheKeys())\n    );\n  }\n}\n\nexport function generateHtmlString(sheets: Array<sheetT>, className: string) {\n  let html = \"\";\n  for (let i = 0; i < sheets.length; i++) {\n    const sheet = sheets[i];\n    const {class: originalClassName, ...rest} = sheet.attrs;\n    const attrs = {\n      class: originalClassName\n        ? `${className} ${originalClassName}`\n        : className,\n      ...(rest as attrsT),\n    };\n    html += `<style${attrsToString(attrs)}>${sheet.css}</style>`;\n  }\n  return html;\n}\n\nfunction attrsToString(attrs: attrsT) {\n  let result = \"\";\n  for (const attr in attrs) {\n    const value = attrs[attr];\n    if (value === true) {\n      result += \" \" + attr;\n    } else if (value !== false) {\n      result += ` ${attr}=\"${value}\"`;\n    }\n  }\n  return result;\n}\n\nfunction stringify(styleRules, sortedCacheKeys) {\n  let result = \"\";\n  sortedCacheKeys.forEach(cacheKey => {\n    const rules = styleRules[cacheKey];\n    if (cacheKey !== \"\") {\n      result += `@media ${cacheKey}{${rules}}`;\n    } else {\n      result += rules;\n    }\n  });\n  return result;\n}\n\nfunction sheetify(styleRules, sortedCacheKeys): Array<sheetT> {\n  if (sortedCacheKeys.length === 0) {\n    return [{css: \"\", attrs: {}}];\n  }\n  const sheets = [];\n  sortedCacheKeys.forEach(cacheKey => {\n    // omit media (cacheKey) attribute if empty\n    const attrs = cacheKey === \"\" ? {} : {media: cacheKey};\n    sheets.push({css: styleRules[cacheKey], attrs});\n  });\n  return sheets;\n}\n\nexport default StyletronServer;\n"
    ]
  },
  "metadata": {},
  "sourceType": "module"
}
