{
  "ast": null,
  "code": "import hyphenate from \"./hyphenate-style-name\";\nimport { validateNoMixedHand } from \"./validate-no-mixed-hand\";\nimport { prefix } from \"inline-style-prefixer\";\nimport { MultiCache } from \"./cache\";\nexport default function injectStylePrefixed(styleCache, styles, media, pseudo) {\n  const cache = styleCache.getCache(media);\n  let classString = \"\";\n\n  for (const originalKey in styles) {\n    const originalVal = styles[originalKey];\n\n    if (originalVal === void 0 || originalVal === null) {\n      continue;\n    }\n\n    if (typeof originalVal !== \"object\") {\n      // Non-null and non-undefined primitive value\n      if (process.env.NODE_ENV !== \"production\") {\n        validateValueType(originalVal, originalKey);\n      }\n\n      const propValPair = `${hyphenate(originalKey)}:${originalVal}`;\n      const key = `${pseudo}${propValPair}`;\n      const cachedId = cache.cache[key];\n\n      if (cachedId !== void 0) {\n        // cache hit\n        classString += \" \" + cachedId;\n        continue;\n      } else {\n        // cache miss\n        let block = \"\";\n        const prefixed = prefix({\n          [originalKey]: originalVal\n        });\n\n        for (const prefixedKey in prefixed) {\n          const prefixedVal = prefixed[prefixedKey];\n          const prefixedValType = typeof prefixedVal;\n\n          if (prefixedValType === \"string\" || prefixedValType === \"number\") {\n            const prefixedPair = `${hyphenate(prefixedKey)}:${prefixedVal}`;\n\n            if (prefixedPair !== propValPair) {\n              block += `${prefixedPair};`;\n            }\n          } else if (Array.isArray(prefixedVal)) {\n            const hyphenated = hyphenate(prefixedKey);\n\n            for (let i = 0; i < prefixedVal.length; i++) {\n              const prefixedPair = `${hyphenated}:${prefixedVal[i]}`;\n\n              if (prefixedPair !== propValPair) {\n                block += `${prefixedPair};`;\n              }\n            }\n          }\n        }\n\n        block += propValPair; // ensure original prop/val is last (for hydration)\n\n        const id = cache.addValue(key, {\n          pseudo,\n          block\n        });\n        classString += \" \" + id;\n      }\n    } else {\n      // Non-null object value\n      if (originalKey[0] === \":\") {\n        classString += \" \" + injectStylePrefixed(styleCache, originalVal, media, pseudo + originalKey);\n      } else if (originalKey.substring(0, 6) === \"@media\") {\n        classString += \" \" + injectStylePrefixed(styleCache, originalVal, originalKey.substr(7), pseudo);\n      }\n    }\n  }\n\n  if (process.env.NODE_ENV !== \"production\") {\n    const conflicts = validateNoMixedHand(styles);\n\n    if (conflicts.length) {\n      conflicts.forEach(_ref => {\n        let {\n          shorthand,\n          longhand\n        } = _ref;\n        const short = JSON.stringify({\n          [shorthand.property]: shorthand.value\n        });\n        const long = JSON.stringify({\n          [longhand.property]: longhand.value\n        }); // eslint-disable-next-line no-console\n\n        console.warn(`Styles \\`${short}\\` and \\`${long}\\` in object yielding class \"${classString.slice(1)}\" may result in unexpected behavior. Mixing shorthand and longhand properties within the same style object is unsupported with atomic rendering.`);\n      });\n    }\n  } // remove leading space\n\n\n  return classString.slice(1);\n}\n\nfunction validateValueType(value, key) {\n  if (value === null || Array.isArray(value) || typeof value !== \"number\" && typeof value !== \"string\") {\n    throw new Error(`Unsupported style value: ${JSON.stringify(value)} used in property ${JSON.stringify(key)}`);\n  }\n}",
  "map": {
    "version": 3,
    "sources": [
      "src/inject-style-prefixed.ts"
    ],
    "names": [
      "cache",
      "styleCache",
      "classString",
      "originalVal",
      "styles",
      "validateValueType",
      "propValPair",
      "hyphenate",
      "key",
      "pseudo",
      "cachedId",
      "block",
      "prefixed",
      "prefix",
      "prefixedVal",
      "prefixedValType",
      "prefixedPair",
      "Array",
      "hyphenated",
      "i",
      "id",
      "originalKey",
      "injectStylePrefixed",
      "conflicts",
      "validateNoMixedHand",
      "longhand",
      "short",
      "shorthand",
      "value",
      "long",
      "console",
      "JSON"
    ],
    "mappings": "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",
    "sourcesContent": [
      "declare var __DEV__: boolean;\n\nimport hyphenate from \"./hyphenate-style-name\";\nimport {validateNoMixedHand} from \"./validate-no-mixed-hand\";\nimport {prefix} from \"inline-style-prefixer\";\n\nimport type {StyleObject} from \"styletron-standard\";\n\nimport {MultiCache} from \"./cache\";\n\nexport default function injectStylePrefixed(\n  styleCache: MultiCache<{\n    pseudo: string;\n    block: string;\n  }>,\n  styles: StyleObject,\n  media: string,\n  pseudo: string,\n) {\n  const cache = styleCache.getCache(media);\n  let classString = \"\";\n  for (const originalKey in styles) {\n    const originalVal = styles[originalKey];\n\n    if (originalVal === void 0 || originalVal === null) {\n      continue;\n    }\n    if (typeof originalVal !== \"object\") {\n      // Non-null and non-undefined primitive value\n      if (__DEV__) {\n        validateValueType(originalVal, originalKey);\n      }\n\n      const propValPair = `${hyphenate(originalKey)}:${\n        originalVal as any as string\n      }`;\n      const key = `${pseudo}${propValPair}`;\n      const cachedId = cache.cache[key];\n      if (cachedId !== void 0) {\n        // cache hit\n        classString += \" \" + cachedId;\n        continue;\n      } else {\n        // cache miss\n        let block = \"\";\n        const prefixed = prefix({[originalKey]: originalVal});\n        for (const prefixedKey in prefixed) {\n          const prefixedVal = prefixed[prefixedKey];\n          const prefixedValType = typeof prefixedVal;\n          if (prefixedValType === \"string\" || prefixedValType === \"number\") {\n            const prefixedPair = `${hyphenate(prefixedKey)}:${prefixedVal}`;\n            if (prefixedPair !== propValPair) {\n              block += `${prefixedPair};`;\n            }\n          } else if (Array.isArray(prefixedVal)) {\n            const hyphenated = hyphenate(prefixedKey);\n            for (let i = 0; i < prefixedVal.length; i++) {\n              const prefixedPair = `${hyphenated}:${prefixedVal[i]}`;\n              if (prefixedPair !== propValPair) {\n                block += `${prefixedPair};`;\n              }\n            }\n          }\n        }\n        block += propValPair; // ensure original prop/val is last (for hydration)\n        const id = cache.addValue(key, {pseudo, block});\n        classString += \" \" + id;\n      }\n    } else {\n      // Non-null object value\n      if (originalKey[0] === \":\") {\n        classString +=\n          \" \" +\n          injectStylePrefixed(\n            styleCache,\n            originalVal as StyleObject,\n            media,\n            pseudo + originalKey,\n          );\n      } else if (originalKey.substring(0, 6) === \"@media\") {\n        classString +=\n          \" \" +\n          injectStylePrefixed(\n            styleCache,\n            originalVal as StyleObject,\n            originalKey.substr(7),\n            pseudo,\n          );\n      }\n    }\n  }\n\n  if (__DEV__) {\n    const conflicts = validateNoMixedHand(styles);\n    if (conflicts.length) {\n      conflicts.forEach(({shorthand, longhand}) => {\n        const short = JSON.stringify({[shorthand.property]: shorthand.value});\n        const long = JSON.stringify({[longhand.property]: longhand.value});\n        // eslint-disable-next-line no-console\n        console.warn(\n          `Styles \\`${short}\\` and \\`${long}\\` in object yielding class \"${classString.slice(\n            1,\n          )}\" may result in unexpected behavior. Mixing shorthand and longhand properties within the same style object is unsupported with atomic rendering.`,\n        );\n      });\n    }\n  }\n\n  // remove leading space\n  return classString.slice(1);\n}\n\nfunction validateValueType(value, key) {\n  if (\n    value === null ||\n    Array.isArray(value) ||\n    (typeof value !== \"number\" && typeof value !== \"string\")\n  ) {\n    throw new Error(\n      `Unsupported style value: ${JSON.stringify(\n        value,\n      )} used in property ${JSON.stringify(key)}`,\n    );\n  }\n}\n"
    ]
  },
  "metadata": {},
  "sourceType": "module"
}
